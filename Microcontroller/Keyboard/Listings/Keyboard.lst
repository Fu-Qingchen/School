C51 COMPILER V9.59.0.0   KEYBOARD                                                          11/15/2018 23:26:38 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE KEYBOARD
OBJECT MODULE PLACED IN .\Objects\Keyboard.obj
COMPILER INVOKED BY: E:\Keil_v5\C51\BIN\C51.EXE Keyboard.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\
                    -Keyboard.lst) TABS(2) OBJECT(.\Objects\Keyboard.obj)

line level    source

   1          /*************************************************
   2          * @Author: fuqingchen@whut.edu.cn
   3          * @Date: 2018-11-12 20:06:29
   4          * @Description: 电话键盘&拨号的模拟
   5          *************************************************/
   6          
   7          #include <reg51.h>
   8          #include <intrins.h>
   9          #include <string.h>
  10          #define KEY P0  //分别读取A,B,C,D,1,2,3
  11          #define LCD P1  //分别控制D0,D1,D2,D3,D4,D5,D6,D7
  12          sbit RS = P2 ^ 0; //控制RS
  13          sbit RW = P2 ^ 1; //控制RW
  14          sbit E  = P2 ^ 2; //控制E
  15          unsigned char str[16];  //LCD1602第二行输出内容
  16          
  17          /*************************************************
  18          * @Description: 延时函数
  19          * @Input: t:延长的时间
  20          *************************************************/
  21          void delay(unsigned int t) {
  22   1        unsigned char i;
  23   1        while (t--) {
  24   2          for (i = 0; i<120; i++);
  25   2        }
  26   1      }
  27          
  28          /*************************************************
  29          * @Description: LCD1602读状态(查忙)
  30          *************************************************/
  31          void check_busy_LCD() {
  32   1        unsigned char pin;
  33   1        do
  34   1        {
  35   2          pin = 0xff;
  36   2          E = 0;
  37   2          RS = 0; RW = 1; E = 1;  //LCD读状态控制信号
  38   2          pin = LCD;
  39   2        } while (pin & 0x80);
  40   1        E = 0;
  41   1      }
  42          
  43          /*************************************************
  44          * @Description: LCD1602写命令
  45          * @Input: com:要写入的命令
  46          *************************************************/
  47          void write_command_LCD(unsigned char com) {
  48   1        check_busy_LCD();
  49   1        RS = 0; RW = 0; //LCD写命令控制信号
  50   1        E = 0; LCD = com; E = 1;  //写命令正脉冲
  51   1        _nop_(); E = 0; delay(1);
  52   1      }
  53          
  54          /*************************************************
C51 COMPILER V9.59.0.0   KEYBOARD                                                          11/15/2018 23:26:38 PAGE 2   

  55          * @Description: LCD1602写数据
  56          * @Input: date:要写入的数据
  57          *************************************************/
  58          void write_data_LCD(unsigned char date) {
  59   1        check_busy_LCD();
  60   1        RS = 1; RW = 0; //LCD写数据控制信号
  61   1        E = 0; LCD = date; E = 1; //写数据正脉冲
  62   1        _nop_(); E = 0; delay(1);
  63   1      }
  64          
  65          /*************************************************
  66          * @Description: LCD1602初始化
  67          *************************************************/
  68          void initial_LCD() {
  69   1        write_command_LCD(0x38);  //两行显示，5*7点阵，8位数据接口
  70   1        _nop_();
  71   1        write_command_LCD(0x0C);  //整体显示，光标关，无显示
  72   1        _nop_();
  73   1        write_command_LCD(0x04);  //整屏不移位
  74   1        _nop_();
  75   1        write_command_LCD(0x01);  //显示清屏
  76   1      }
  77          
  78          /*************************************************
  79          * @Description: LCD1602显示字符串
  80          * @Input: address:字符串位置;*s:字符串;length:字符串长度
  81          *************************************************/
  82          void show_string_LCD(unsigned char address, unsigned char *s, unsigned int length) {
  83   1        unsigned int i;
  84   1        write_command_LCD(address);
  85   1        delay(5);
  86   1        for (i = 0; i < length; i++)
  87   1        {
  88   2          write_data_LCD(*(s + i));
  89   2        }
  90   1      }
  91          
  92          /*************************************************
  93          * @Description: 根据输入在LCD上的操作
  94          * @Input: no:读取的键盘字符[0,1,2,3,4,5,6,7,8,9,*,#]
  95          *************************************************/
  96          void get_No(int no) {
  97   1        char str2;
  98   1        if (no < 10)  //输入数字时，加一位数字
  99   1        {
 100   2          str2 = no + 48; //将no给str2,48为ASCII码
 101   2          if (strlen(str)<16)
 102   2          {
 103   3            strcat(str, &str2); //加一位数字
 104   3          }
 105   2        }
 106   1        else if (no == 10)  //输入 * 时，去一位数字
 107   1        {
 108   2          write_command_LCD(0x01);  //显示清屏
 109   2          delay(5);
 110   2          show_string_LCD(0x82, "#FU_QINGCHEN", 12);
 111   2          *(str + strlen(str) - 1) = 0;
 112   2          *(str + strlen(str)) = 0;
 113   2        }
 114   1        else    //输入 # 时，清屏
 115   1        {
 116   2          *str = 0;
C51 COMPILER V9.59.0.0   KEYBOARD                                                          11/15/2018 23:26:38 PAGE 3   

 117   2          write_command_LCD(0x01);  //显示清屏
 118   2          delay(5);
 119   2          show_string_LCD(0x82, "#FU_QINGCHEN", 12);
 120   2          _nop_();
 121   2          delay(500);
 122   2        }
 123   1        show_string_LCD(0xC0, str, strlen(str));
 124   1        delay(5);
 125   1      }
 126          
 127          /*************************************************
 128          * @Description: 输入 # 时清屏
 129          *************************************************/
 130          void get_sign() {
 131   1        //write_command_LCD(0x01);  //显示清屏
 132   1        delay(50);
 133   1        show_string_LCD(0x82, "#FU_QINGCHEN", 12);
 134   1        _nop_();
 135   1        delay(100);
 136   1      }
 137          
 138          /*************************************************
 139          * @Description: 读取键盘的输入内容
 140          *************************************************/
 141          void getKeyValue() {
 142   1        int i;
 143   1        unsigned char R;  //行扫描值
 144   1        unsigned char C;  //列扫描值
 145   1        unsigned char RC; //坐标
 146   1        unsigned char code_key;
 147   1        KEY = 0x0F; //ABCD取高电平，123取低电平
 148   1        if (KEY!=0x0F)  //KEY出现变化说明输入
 149   1        {
 150   2          delay(15);  //去抖动
 151   2          if ((KEY|0xF0)!=0xFF)
 152   2          {
 153   3            R = (~KEY) & 0x0F;  //获取行值
 154   3            code_key = 0xEF;
 155   3            C = 0x10;
 156   3            for (i = 0; i < 3; i++)
 157   3            {
 158   4              KEY = code_key;
 159   4              if ((KEY|0xF0)!=0xFF)
 160   4              {
 161   5                RC = R | C;
 162   5                switch (RC)
 163   5                {
 164   6                case 0x28:get_No(0); break;
 165   6                case 0x11:get_No(1); break;
 166   6                case 0x21:get_No(2); break;
 167   6                case 0x41:get_No(3); break;
 168   6                case 0x12:get_No(4); break;
 169   6                case 0x22:get_No(5); break;
 170   6                case 0x42:get_No(6); break;
 171   6                case 0x14:get_No(7); break;
 172   6                case 0x24:get_No(8); break;
 173   6                case 0x44:get_No(9); break;
 174   6                case 0x18:get_No(10); break;
 175   6                case 0x48:get_No(11); break;
 176   6                }
 177   5                break;
 178   5              }
C51 COMPILER V9.59.0.0   KEYBOARD                                                          11/15/2018 23:26:38 PAGE 4   

 179   4              code_key = _crol_(code_key, 1);
 180   4              C = _crol_(C, 1);
 181   4            }
 182   3          }
 183   2        }
 184   1      }
 185          
 186          void main() {
 187   1        initial_LCD();
 188   1        while (1)
 189   1        {
 190   2          get_sign();
 191   2          getKeyValue();
 192   2          //write_command_LCD(0x01);  //清屏
 193   2          delay(100);
 194   2        }
 195   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    608    ----
   CONSTANT SIZE    =     13    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     16      16
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
